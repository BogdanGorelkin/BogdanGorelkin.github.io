<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0066)file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NBdlNBCCH</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-01-11"><meta name="DC.source" content="NBdlNBCCH.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#2">Generating a message of random numbers (0,1)</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#3">Convolutional encoding</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#4">Interleaver</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#5">Modulator</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#6">Adding noise | Добавлние шумов</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#7">Receiver | Приёмник</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#8">Decoding</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#9">Graphic display | Графическое отображение</a></li><li><a href="file:///C:/Users/bgore/Desktop/N-BCCH%20GitHub/html/NBdlNBCCH.html#10">Comparison Before and After | Сравнение До и После</a></li></ul></div><pre class="codeinput"><span class="comment">% https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=2719</span>
<span class="comment">%</span>
<span class="comment">% Description of physical layer parameters on the page 136 in 45820-d10.doc</span>
<span class="comment">% описание физического уровная на странице 136 45820-d10.doc</span>
<span class="comment">%</span>
<span class="comment">% https://b.gorelkin.me/documents/N-BCCH/45820-d10.doc</span>
<span class="comment">% https://b.gorelkin.me/documents/N-BCCH/36212-f40.docx</span>
<span class="comment">%======================================================================================</span>
<span class="comment">%| Payload = 152;        | Длина массива (Полезная нагрузка)                           |</span>
<span class="comment">%| CRC = 18;             | Контрольная сумма 36212-f40-&gt; раздел 5.1.1 "CRC calculation"|</span>
<span class="comment">%| TailBits = 6;         | Защитный интервал (защита от межсимвольной интерференции)   |</span>
<span class="comment">%| N = Payload + CRC;    | Итоговая длина массива                                      |</span>
<span class="comment">%| BIT=randi([0 1],1,N); | Передаваемые данные                                         |</span>
<span class="comment">%| CP = 20;              | Длина цикллического префикса                                |</span>
<span class="comment">%=======================================================================================</span>
<span class="comment">%=======================================================================================</span>
<span class="comment">%| Payload = 152;        | Array length, (informational message)                       |</span>
<span class="comment">%| CRC = 18;             | Check sum 36212-f40-&gt; Section 5.1.1 "CRC calculation"       |</span>
<span class="comment">%| TailBits = 6;         | Guard interval (ISI protection - InterSymbol Interference)  |</span>
<span class="comment">%| N = Payload + CRC;    | Итоговая длина массива                                      |</span>
<span class="comment">%| BIT=randi([0 1],1,N); | Передаваемые данные                                         |</span>
<span class="comment">%| CP = 20;              | Cyclic prefix length                                        |</span>
<span class="comment">%=======================================================================================</span>

clc
clear <span class="string">all</span>
close <span class="string">all</span>
</pre><h2 id="2">Generating a message of random numbers (0,1)</h2><p>Генерация массива рандомных чисел (0,1)</p><pre class="codeinput">Payload = 152;
CRClength = 18;
CRC = [randi([0 1],1, CRClength)];
TailBits = 6;
BIT = [randi([0 1], 1, Payload),CRC]
CP = 20;
</pre>
<h2 id="3">Convolutional encoding</h2><p>Сверточне кодирование encoded with the 1/3 rate convolutional mother code defined by the polynomials: G4 = 1 + D2 + D3 + D5 + D6 G5 = 1 + D + D4 + D6 G6 = 1 + D + D2 + D3 + D4 + D6</p><pre class="codeinput">trel = poly2trellis(7,[171 133 165]); <span class="comment">% Encoding lattice | Решетка кодирования</span>
tblen = TailBits; <span class="comment">% Depth of viewing when decoding | Глубина просмотра при декодировании</span>
zero = zeros(1,tblen);
<span class="comment">% an array of length tblen was added to the BIT sequence so that no bits are cut off during decoding</span>
BITunited = [BIT,zero]; <span class="comment">% к последовательности BIT добавили массив длиной tblen, для того чтобы при декодировании не обрезались биты</span>
<span class="comment">% Since the rate of the convolutional encoder 1/3 at the output of the message is increased by 3 times (Overcoding)</span>
codeBIT = convenc(BITunited,trel);   <span class="comment">% т.к. скорость сверточного кодера 1/3 на выходе сообщение увеличчивается в 3 раза (Избыточное кодирование)</span>

<span class="comment">% The second version of the convolutional coding</span>
<span class="comment">% Вторая версия сверточного кодирования</span>
<span class="comment">%   trel = struct(...</span>
<span class="comment">%     'numInputSymbols',2,...</span>
<span class="comment">%     'numOutputSymbols',8,...</span>
<span class="comment">%     'numStates',4,...</span>
<span class="comment">%     'nextStates',[0 2;0 2;1 3;1 3],...</span>
<span class="comment">%     'outputs',[0 3;1 2;3 0;2 1]);</span>

Jpuncturing=1:80; <span class="comment">%Punching values 45820-d10 -&gt; page 137 | Значения для выкалывания 45820-d10-&gt;страница 137</span>
<span class="comment">%The code is punctured in such a way that the next 80 encoded bits are not transmitted.</span>
C=23+5*Jpuncturing; <span class="comment">%Код прокололся таким образом, что следующие 80 закодированных битов не передаются.</span>
<span class="comment">%The result is a block of 448 encoded and punctured bits, P (0) ... P (447).</span>
codeBIT_punct = codeBIT; <span class="comment">%В результате получается блок из 448 кодированных и проколотых битов, P (0) ... P (447).</span>
codeBIT_punct (C)=[];
</pre><h2 id="4">Interleaver</h2><p>Перемежитель Sets the initial state of the random number generator, which is used to calculate the permutation order. The permutations generated for any fixed value of the state parameter are repeatable and reversible; however, different values of state will give different permutations.</p><pre class="codeinput">state = 0; <span class="comment">%задает начальное состояние генератора случайных чисел, который используется при расчете порядка перестановки. Перестановки, генерируемые для любого фиксированного значения параметра state, являются повторяемыми и обратимыми, однако разные значения state дадут разные перестановки.</span>
codeBIT2 = randintrlv(codeBIT_punct,state);
<span class="comment">% Ready sequence for transmission to the modulator</span>
y = codeBIT2; <span class="comment">%Готовая последовательность к передаче = y</span>
</pre><h2 id="5">Modulator</h2><p>Модулятор</p><pre class="codeinput"><span class="keyword">for</span> i = 1 : length(y) / 2

    <span class="keyword">if</span> y(2*(i-1)+1)==1 &amp;&amp; y(2*i)==1
        outmod(i)=0.707+1i*0.707;
    <span class="keyword">end</span>

    <span class="keyword">if</span> y(2*(i-1)+1)==1 &amp;&amp; y(2*i)==0
        outmod(i)=-0.707+1i*0.707;
    <span class="keyword">end</span>

    <span class="keyword">if</span> y(2*(i-1)+1)==0 &amp;&amp; y(2*i)==0
        outmod(i)=-0.707-1i*0.707;
    <span class="keyword">end</span>

    <span class="keyword">if</span> y(2*(i-1)+1)==0 &amp;&amp; y(2*i)==1
        outmod(i)=0.707-1i*0.707;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Guard interval length (left and right) Zint = Total symbol duration minus useful symbol duration (1/4, 1/8, 1/16, or 1/32 of the OFDM symbol duration)</span>
<span class="comment">% Длина защитного интервала (слева и справа)Zint=Полная длительность символа минус полезная длительность симмвола (1/4, 1/8, 1/16 или 1/32 от длительности OFDM символа)</span>
SpecOFDM = [zeros(1,TailBits), outmod(1:length(outmod)/2),0,outmod(length(outmod)/2+1:end), zeros(1,TailBits)];
<span class="comment">%____inverse fourier transform | обратное преобразование фурье____%</span>
OPF = ifft(SpecOFDM);
TimeFFT = OPF;
<span class="comment">%____Adding a cyclic prefix | Добавление циклического префикса____%</span>
Z = TimeFFT((length(TimeFFT)-CP+1):end);
o = [Z(1:end)  TimeFFT];
</pre><h2 id="6">Adding noise | Добавлние шумов</h2><pre class="codeinput">SNR = 10,4;
Noise=awgn(o,SNR,<span class="string">'measured'</span>); <span class="comment">% awgn(Массив, величина SNR, 'считает сам по мощности сигнала')</span>
<span class="comment">%ncodeBIT = rem(codeBIT + randerr(200,1,[0 1;.95 .05]),2); %awgn (взять из гугла)Добавляю шум</span>
</pre>
<h2 id="7">Receiver | Приёмник</h2><pre class="codeinput"><span class="comment">%____Remove cyclic prefix | Удалине циклического префикса____%</span>
Z1 = Noise((CP+1):length(Noise));
<span class="comment">%___Fourier Transform | Прямое преобразование Фурье____%</span>
TimeFFT = fft(Z1);
<span class="comment">%___Removing the guard interval | Убираем защитный интервал____%</span>
SpecOFDM1 = [TimeFFT(TailBits+1:length(TimeFFT)/2),TimeFFT(length(TimeFFT)/2+1:end-TailBits)];

<span class="comment">%___Demodulator | Демодулятор</span>
<span class="keyword">for</span> i = 1 : length(SpecOFDM1)
    <span class="keyword">if</span> real(SpecOFDM1(i))&gt;0 &amp;&amp; imag(SpecOFDM1(i))&gt;0
        outdemod((i-1)*2+1)=1
        outdemod(2*i)=1;
    <span class="keyword">end</span>

    <span class="keyword">if</span> real(SpecOFDM1(i))&lt;0 &amp;&amp; imag(SpecOFDM1(i))&gt;0
        outdemod((i-1)*2+1)=1
        outdemod(2*i)=0;
    <span class="keyword">end</span>

     <span class="keyword">if</span> real(SpecOFDM1(i))&lt;0 &amp;&amp; imag(SpecOFDM1(i))&lt;0
        outdemod((i-1)*2+1)=0
        outdemod(2*i)=0;
     <span class="keyword">end</span>

    <span class="keyword">if</span> real(SpecOFDM1(i))&gt;0 &amp;&amp; imag(SpecOFDM1(i))&lt;0
        outdemod((i-1)*2+1)=0
        outdemod(2*i)=1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<h2 id="8">Decoding</h2><p>Декодирование</p><pre class="codeinput"><span class="comment">%____Interleaved DECoding | Перемежительное ДЕкодирование____%</span>
decodeBIT2 = randdeintrlv(outdemod,state);
<span class="comment">% The result is a block of 448 encoded and punctured bits, P (0) ... P (447).</span>
<span class="comment">% INSERT ELEMENTS INSIDE THE ARRAY at puncture sites 23 to 344</span>
<span class="comment">%В результате получается блок из 448 кодированных и проколотых битов, P (0) ... P (447).</span>
<span class="comment">%ВСТАВИТЬ ЭЛЕМЕНТЫ ВНУТРЬ МАССИВА на места проколов с 23 по 344 элемент</span>
z = zeros(1,528);
z1 = [decodeBIT2(1:23)]
z2 = [decodeBIT2(344:end)]

n = 24;
<span class="keyword">for</span> i = 24:5:423
    z(i) = decodeBIT2(n);
    n=n+1;
    z(i+1) = decodeBIT2(n);
    n=n+1;
    z(i+2) = decodeBIT2(n);
    n=n+1;
    z(i+3) = decodeBIT2(n);
    n=n+1;
<span class="keyword">end</span>
codeBIT_DEpunct = [z1(1:end),z(24:423),z2(1:end)];

<span class="comment">% %____Convolutional DECODE | Сверточное ДЕкодирование____%</span>
decodeBIT = vitdec(codeBIT_DEpunct,trel,tblen,<span class="string">'cont'</span>,<span class="string">'hard'</span>);
</pre>
<h2 id="9">Graphic display | Графическое отображение</h2><pre class="codeinput">scatterplot(outmod); <span class="comment">%figure (1) созвездие</span>
grid <span class="string">on</span>
xlabel(<span class="string">'Re'</span>)
ylabel(<span class="string">'Im'</span>)
figure
plot(abs(SpecOFDM));
figure
plot(abs(TimeFFT));
scatterplot(SpecOFDM1);
figure
plot(1:length(TimeFFT),abs(TimeFFT));
figure
plot(outdemod);
scatterplot(outdemod);
</pre><img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_01.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_02.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_03.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_04.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_05.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_06.png" alt=""> <img vspace="5" hspace="5" src="./NBdlNBCCH_files/NBdlNBCCH_07.png" alt=""> <h2 id="10">Comparison Before and After | Сравнение До и После</h2><pre class="codeinput">a = [BITunited((1:length(decodeBIT)-TailBits))];
b = [decodeBIT(TailBits+1:length(BITunited))];
raznica = a/b; <span class="comment">% If equal to 1 then the message was transmitted without errors</span>
sravnivanie(1,:) = [BITunited((1:length(decodeBIT)-TailBits))];
sravnivanie(2,:) = [decodeBIT(TailBits+1:length(BITunited))];
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB® R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
% https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=2719
% 
% Description of physical layer parameters on the page 136 in 45820-d10.doc
% описание физического уровная на странице 136 45820-d10.doc
%
% https://b.gorelkin.me/documents/N-BCCH/45820-d10.doc
% https://b.gorelkin.me/documents/N-BCCH/36212-f40.docx
%======================================================================================
%| Payload = 152;        | Длина массива (Полезная нагрузка)                           |
%| CRC = 18;             | Контрольная сумма 36212-f40-> раздел 5.1.1 "CRC calculation"|
%| TailBits = 6;         | Защитный интервал (защита от межсимвольной интерференции)   |
%| N = Payload + CRC;    | Итоговая длина массива                                      |
%| BIT=randi([0 1],1,N); | Передаваемые данные                                         |
%| CP = 20;              | Длина цикллического префикса                                |
%=======================================================================================
%=======================================================================================
%| Payload = 152;        | Array length, (informational message)                       |
%| CRC = 18;             | Check sum 36212-f40-> Section 5.1.1 "CRC calculation"       |
%| TailBits = 6;         | Guard interval (ISI protection - InterSymbol Interference)  |
%| N = Payload + CRC;    | Итоговая длина массива                                      |
%| BIT=randi([0 1],1,N); | Передаваемые данные                                         |
%| CP = 20;              | Cyclic prefix length                                        |
%=======================================================================================

clc
clear all
close all
%% Generating a message of random numbers (0,1)
% Генерация массива рандомных чисел (0,1)

Payload = 152; 
CRClength = 18;
CRC = [randi([0 1],1, CRClength)]; 
TailBits = 6;
BIT = [randi([0 1], 1, Payload),CRC]
CP = 20; 
%% Convolutional encoding
% Сверточне кодирование
% encoded with the 1/3 rate convolutional mother code defined by the polynomials:
% G4 = 1 + D2 + D3 + D5 + D6 
% G5 = 1 + D + D4 + D6 
% G6 = 1 + D + D2 + D3 + D4 + D6

trel = poly2trellis(7,[171 133 165]); % Encoding lattice | Решетка кодирования
tblen = TailBits; % Depth of viewing when decoding | Глубина просмотра при декодировании 
zero = zeros(1,tblen); 
% an array of length tblen was added to the BIT sequence so that no bits are cut off during decoding
BITunited = [BIT,zero]; % к последовательности BIT добавили массив длиной tblen, для того чтобы при декодировании не обрезались биты
% Since the rate of the convolutional encoder 1/3 at the output of the message is increased by 3 times (Overcoding)
codeBIT = convenc(BITunited,trel);   % т.к. скорость сверточного кодера 1/3 на выходе сообщение увеличчивается в 3 раза (Избыточное кодирование)

% The second version of the convolutional coding
% Вторая версия сверточного кодирования
%   trel = struct(...                   
%     'numInputSymbols',2,...
%     'numOutputSymbols',8,...
%     'numStates',4,...
%     'nextStates',[0 2;0 2;1 3;1 3],...
%     'outputs',[0 3;1 2;3 0;2 1]);  

Jpuncturing=1:80; %Punching values 45820-d10 -> page 137 | Значения для выкалывания 45820-d10->страница 137
%The code is punctured in such a way that the next 80 encoded bits are not transmitted.
C=23+5*Jpuncturing; %Код прокололся таким образом, что следующие 80 закодированных битов не передаются. 
%The result is a block of 448 encoded and punctured bits, P (0) ... P (447).
codeBIT_punct = codeBIT; %В результате получается блок из 448 кодированных и проколотых битов, P (0) ... P (447).
codeBIT_punct (C)=[];


%% Interleaver 
% Перемежитель
% Sets the initial state of the random number generator, which is used to calculate the permutation order. 
% The permutations generated for any fixed value of the state parameter are repeatable and reversible;
% however, different values of state will give different permutations.
state = 0; %задает начальное состояние генератора случайных чисел, который используется при расчете порядка перестановки. Перестановки, генерируемые для любого фиксированного значения параметра state, являются повторяемыми и обратимыми, однако разные значения state дадут разные перестановки.
codeBIT2 = randintrlv(codeBIT_punct,state);
% Ready sequence for transmission to the modulator
y = codeBIT2; %Готовая последовательность к передаче = y

%% Modulator
% Модулятор
for i = 1 : length(y) / 2
  
    if y(2*(i-1)+1)==1 && y(2*i)==1 
        outmod(i)=0.707+1i*0.707;
    end
    
    if y(2*(i-1)+1)==1 && y(2*i)==0
        outmod(i)=-0.707+1i*0.707;
    end
        
    if y(2*(i-1)+1)==0 && y(2*i)==0
        outmod(i)=-0.707-1i*0.707;
    end
    
    if y(2*(i-1)+1)==0 && y(2*i)==1
        outmod(i)=0.707-1i*0.707;
    end
end
% Guard interval length (left and right) Zint = Total symbol duration minus useful symbol duration (1/4, 1/8, 1/16, or 1/32 of the OFDM symbol duration)
% Длина защитного интервала (слева и справа)Zint=Полная длительность символа минус полезная длительность симмвола (1/4, 1/8, 1/16 или 1/32 от длительности OFDM символа)
SpecOFDM = [zeros(1,TailBits), outmod(1:length(outmod)/2),0,outmod(length(outmod)/2+1:end), zeros(1,TailBits)];
%____inverse fourier transform | обратное преобразование фурье____%
OPF = ifft(SpecOFDM);
TimeFFT = OPF;
%____Adding a cyclic prefix | Добавление циклического префикса____%
Z = TimeFFT((length(TimeFFT)-CP+1):end);
o = [Z(1:end)  TimeFFT];
%% Adding noise | Добавлние шумов
SNR = 10,4;
Noise=awgn(o,SNR,'measured'); % awgn(Массив, величина SNR, 'считает сам по мощности сигнала')
%ncodeBIT = rem(codeBIT + randerr(200,1,[0 1;.95 .05]),2); %awgn (взять из гугла)Добавляю шум
%% Receiver | Приёмник

%____Remove cyclic prefix | Удалине циклического префикса____%
Z1 = Noise((CP+1):length(Noise));
%___Fourier Transform | Прямое преобразование Фурье____%
TimeFFT = fft(Z1);
%___Removing the guard interval | Убираем защитный интервал____%
SpecOFDM1 = [TimeFFT(TailBits+1:length(TimeFFT)/2),TimeFFT(length(TimeFFT)/2+1:end-TailBits)];

%___Demodulator | Демодулятор
for i = 1 : length(SpecOFDM1)
    if real(SpecOFDM1(i))>0 && imag(SpecOFDM1(i))>0 
        outdemod((i-1)*2+1)=1
        outdemod(2*i)=1;
    end
    
    if real(SpecOFDM1(i))<0 && imag(SpecOFDM1(i))>0 
        outdemod((i-1)*2+1)=1
        outdemod(2*i)=0;
    end
    
     if real(SpecOFDM1(i))<0 && imag(SpecOFDM1(i))<0 
        outdemod((i-1)*2+1)=0
        outdemod(2*i)=0;
     end
     
    if real(SpecOFDM1(i))>0 && imag(SpecOFDM1(i))<0 
        outdemod((i-1)*2+1)=0
        outdemod(2*i)=1;
    end
end
%% Decoding
% Декодирование
%____Interleaved DECoding | Перемежительное ДЕкодирование____%
decodeBIT2 = randdeintrlv(outdemod,state);
% The result is a block of 448 encoded and punctured bits, P (0) ... P (447).
% INSERT ELEMENTS INSIDE THE ARRAY at puncture sites 23 to 344 
%В результате получается блок из 448 кодированных и проколотых битов, P (0) ... P (447).
%ВСТАВИТЬ ЭЛЕМЕНТЫ ВНУТРЬ МАССИВА на места проколов с 23 по 344 элемент
z = zeros(1,528);
z1 = [decodeBIT2(1:23)]
z2 = [decodeBIT2(344:end)]

n = 24;
for i = 24:5:423
    z(i) = decodeBIT2(n);
    n=n+1;
    z(i+1) = decodeBIT2(n);
    n=n+1;
    z(i+2) = decodeBIT2(n);
    n=n+1;
    z(i+3) = decodeBIT2(n);
    n=n+1;
end
codeBIT_DEpunct = [z1(1:end),z(24:423),z2(1:end)];
 
% %____Convolutional DECODE | Сверточное ДЕкодирование____%
decodeBIT = vitdec(codeBIT_DEpunct,trel,tblen,'cont','hard');

%% Graphic display | Графическое отображение
scatterplot(outmod); %figure (1) созвездие
grid on
xlabel('Re')
ylabel('Im')
figure
plot(abs(SpecOFDM)); 
figure
plot(abs(TimeFFT));
scatterplot(SpecOFDM1);
figure
plot(1:length(TimeFFT),abs(TimeFFT));
figure
plot(outdemod);
scatterplot(outdemod);
%% Comparison Before and After | Сравнение До и После
a = [BITunited((1:length(decodeBIT)-TailBits))];
b = [decodeBIT(TailBits+1:length(BITunited))]; 
raznica = a/b; % If equal to 1 then the message was transmitted without errors
sravnivanie(1,:) = [BITunited((1:length(decodeBIT)-TailBits))];     
sravnivanie(2,:) = [decodeBIT(TailBits+1:length(BITunited))];      





##### SOURCE END #####
--></body></html>